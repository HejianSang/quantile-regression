#' quantile regression
weights=rep(N/n,n)
PI=rep(n/N,n)
r.regression=rq(Y~X,tau=tau0,data=A,weights=weights)
q.direct=weighted.quantile(A[,2],tau,weights)
theta.w=q.direct+(sum(r.regression$coef*pop[,1])-sum(weights*(r.regression$coef*A[,1])))/N
tau0=0.5
tau=0.5
N=dim(pop)[1]
#' SRS samples
A=pop[sample(1:N,n,replace=FALSE),]
#' quantile regression
weights=rep(N/n,n)
PI=rep(n/N,n)
r.regression=rq(Y~X,tau=tau0,data=A,weights=weights)
q.direct=weighted.quantile(A[,2],tau,weights)
theta.w=q.direct+(sum(r.regression$coef*pop[,1])-sum(weights*(r.regression$coef*A[,1])))/N
q=r.regression$coef*A[,1]
q
q.hat=r.regression$coef*A[,1]
Den=matrix(0,2,2)
Den
num=matrix(0,2,1)
Num=matrix(0,2,1)
num*3
5+Den*3
q=r.regression$coef*A[,1]
PIJ=matrix(n*(n-1)/N/(N-1),n,n)
PIJ
diag(PIJ)=weights
PIJ[1:4,1:4]
n/N
diag(PIJ)=1/weights
Den=matrix(0,2,2)
Num=matrix(0,2,1)
for(i in  1:n)
{
Den=Den+weights[i]*matrix(c(1,q[i],q[i],q[i]^2),2,2)
Num=Num+weights[i]*matrix(c(1,q[i]),2,1)*(A[i,2]<theta.w)
}
C=solve(Den)%*%Num
z=(A[,2]<theta.w)-matrix(c(rep(1,n),q),n,2)%*%C
dim(z)
z
z[1]
PIJ=matrix(n*(n-1)/N/(N-1),n,n)
diag(PIJ)=1/weights
V.hat=0
for(i in 1:n)
for(j in 1:n)
V.hat=V.hat+(PIJ[i,j]-PI[i]*PI[j])/(PIJ[i,j])*z[i]*z[j]/(PI[i]*PI[j])
V.hat
?bkde
bin=bkde(A[,2],kernel="normal")
bin
summary(bin)
theta.w
max(which(x<theta.w))
max(which(bin$x<theta.w))
bin$x[201:205]
plot(bin$x,bin$y)
all(bin$x==sort(bin$x))
density=bkde(A[,2],kernel="normal")
index=which.min(density$x>theta.w)
index
theta.w
head(density.x)
head(density$x)
density$x>theta.w
min(which(density$x>theta.w))
index=min(which(density$x>theta.w))
f.theta=(density$y[index]+density$y[index-1])/2
V.theta=V.hat/f.theta^2
V.theta
f.theta=
f.theta
var.kernel=function(pop,n,tau,tau0)
{
N=dim(pop)[1]
#' SRS samples
A=pop[sample(1:N,n,replace=FALSE),]
#' quantile regression
weights=rep(N/n,n)
PI=rep(n/N,n)
r.regression=rq(Y~X,tau=tau0,data=A,weights=weights)
q.direct=weighted.quantile(A[,2],tau,weights)
theta.w=q.direct+(sum(r.regression$coef*pop[,1])-sum(weights*(r.regression$coef*A[,1])))/N
q=r.regression$coef*A[,1]
Den=matrix(0,2,2)
Num=matrix(0,2,1)
for(i in  1:n)
{
Den=Den+weights[i]*matrix(c(1,q[i],q[i],q[i]^2),2,2)
Num=Num+weights[i]*matrix(c(1,q[i]),2,1)*(A[i,2]<theta.w)
}
C=solve(Den)%*%Num
z=(A[,2]<theta.w)-matrix(c(rep(1,n),q),n,2)%*%C
PIJ=matrix(n*(n-1)/N/(N-1),n,n)
diag(PIJ)=1/weights
V.hat=0
for(i in 1:n)
for(j in 1:n)
V.hat=V.hat+(PIJ[i,j]-PI[i]*PI[j])/(PIJ[i,j])*z[i]*z[j]/(PI[i]*PI[j])
#' to estimate the density of y
density=bkde(A[,2],kernel="normal")
index=min(which(density$x>theta.w))
f.theta=(density$y[index]+density$y[index-1])/2
V.theta=V.hat/f.theta^2
return(list(theta.w=theta.w,V.hat=v.hat,V.theta=V.theta))
}
var.kernel(pop1,100,0.5,0.5)
var.kernel=function(pop,n,tau,tau0)
{
N=dim(pop)[1]
#' SRS samples
A=pop[sample(1:N,n,replace=FALSE),]
#' quantile regression
weights=rep(N/n,n)
PI=rep(n/N,n)
r.regression=rq(Y~X,tau=tau0,data=A,weights=weights)
q.direct=weighted.quantile(A[,2],tau,weights)
theta.w=q.direct+(sum(r.regression$coef*pop[,1])-sum(weights*(r.regression$coef*A[,1])))/N
q=r.regression$coef*A[,1]
Den=matrix(0,2,2)
Num=matrix(0,2,1)
for(i in  1:n)
{
Den=Den+weights[i]*matrix(c(1,q[i],q[i],q[i]^2),2,2)
Num=Num+weights[i]*matrix(c(1,q[i]),2,1)*(A[i,2]<theta.w)
}
C=solve(Den)%*%Num
z=(A[,2]<theta.w)-matrix(c(rep(1,n),q),n,2)%*%C
PIJ=matrix(n*(n-1)/N/(N-1),n,n)
diag(PIJ)=1/weights
V.hat=0
for(i in 1:n)
for(j in 1:n)
V.hat=V.hat+(PIJ[i,j]-PI[i]*PI[j])/(PIJ[i,j])*z[i]*z[j]/(PI[i]*PI[j])
#' to estimate the density of y
density=bkde(A[,2],kernel="normal")
index=min(which(density$x>theta.w))
f.theta=(density$y[index]+density$y[index-1])/2
V.theta=V.hat/f.theta^2
return(list(theta.w=theta.w,V.hat=V.hat,V.theta=V.theta))
}
var.kernel(pop1,100,0.5,0.5)
summary(z)
Den
Num=
z
summary(PIJ)
sum(z)*N/n
sum(z)
summary(z)
PIJ[1:10,1:10]
V.hat=0
for(i in 1:n)
for(j in 1:n)
V.hat=V.hat+(PIJ[i,j]-PI[i]*PI[j])*z[i]*z[j]/(PIJ[i,j]*PI[i]*PI[j])
V.hat
N=dim(pop)[1]
#' SRS samples
A=pop[sample(1:N,n,replace=FALSE),]
#' quantile regression
weights=rep(N/n,n)
PI=rep(n/N,n)
r.regression=rq(Y~X,tau=tau0,data=A,weights=weights)
q.direct=weighted.quantile(A[,2],tau,weights)
theta.w=q.direct+(sum(r.regression$coef*pop[,1])-sum(weights*(r.regression$coef*A[,1])))/N
q=r.regression$coef*A[,1]
theta.w
A[,2]
sum(A[,2]>=theta.w)
q=r.regression$coef*A[,1]
q
(A[,2]<theta.w)-
(A[,2]<theta.w)
sum((A[,2]<theta.w))
matrix(c(rep(1,n),q),n,2)%*%C
C
mean(z)
var(z)
var.kernel=function(pop,n,tau,tau0)
{
N=dim(pop)[1]
#' SRS samples
A=pop[sample(1:N,n,replace=FALSE),]
#' quantile regression
weights=rep(N/n,n)
PI=rep(n/N,n)
r.regression=rq(Y~X,tau=tau0,data=A,weights=weights)
q.direct=weighted.quantile(A[,2],tau,weights)
theta.w=q.direct+(sum(r.regression$coef*pop[,1])-sum(weights*(r.regression$coef*A[,1])))/N
q=r.regression$coef*A[,1]
Den=matrix(0,2,2)
Num=matrix(0,2,1)
for(i in  1:n)
{
Den=Den+weights[i]*matrix(c(1,q[i],q[i],q[i]^2),2,2)
Num=Num+weights[i]*matrix(c(1,q[i]),2,1)*(A[i,2]<theta.w)
}
C=solve(Den)%*%Num
z=(A[,2]<theta.w)-matrix(c(rep(1,n),q),n,2)%*%C
PIJ=matrix(n*(n-1)/N/(N-1),n,n)
diag(PIJ)=1/weights
V.hat=var(z)
#   for(i in 1:n)
#     for(j in 1:n)
#       V.hat=V.hat+(PIJ[i,j]-PI[i]*PI[j])*z[i]*z[j]/(PIJ[i,j]*PI[i]*PI[j])
#' to estimate the density of y
density=bkde(A[,2],kernel="normal")
index=min(which(density$x>theta.w))
f.theta=(density$y[index]+density$y[index-1])/2
V.theta=V.hat/f.theta^2
return(list(theta.w=theta.w,V.hat=V.hat,V.theta=V.theta))
}
var.kernel(pop1,100,0.5,0.5)
library(snow)
sfInit( parallel=TRUE, cpus=4)
r=sfSapply(1:5000,function(o) var.kernel(pop1,100,0.5,0.5))
sfStop()
library(snow)
sfInit( parallel=TRUE, cpus=4)
library(snowfall)
sfInit( parallel=TRUE, cpus=4)
r=sfSapply(1:5000,function(o) var.kernel(pop1,100,0.5,0.5))
r=sapply(1:5000,function(o) var.kernel(pop1,100,0.5,0.5))
r=sapply(1:5,function(o) var.kernel(pop1,100,0.5,0.5))
r
r=sapply(1:5000,function(o) var.kernel(pop1,100,0.5,0.5))
dim(r)
r[,1:3]
V.true=var(r[1,])
str(r)
str(r)
dim(r)
r[1,1:10]
r[1,1:3]
r[,1:3]
E.V.hat=mean(unlist(r[3,]))
V.true=var(unlis(r[1,]))
V.true=var(unlist(r[1,]))
(E.V.hat-V.true-1)*100
E.V.hat
V.true
#' function to use callibrartion to estimate the quantile
fw=function(sample,weights,tau,tau0)
{
A=sample
weights=weights
r.regression=rq(Y~X,tau=tau0,data=A,weights=weights)
q.direct=weighted.quantile(A[,2],tau,weights)
q.direct+(sum(r.regression$coef*pop[,1])-sum(weights*(r.regression$coef*A[,1])))/N
}
fw(A,weights,0.5,0.5)
fw=function(sample,weights,tau,tau0)
{
N=1000
n=length(weights)
A=sample
weights=weights
r.regression=rq(Y~X,tau=tau0,data=A,weights=weights)
q.direct=weighted.quantile(A[,2],tau,weights)
q.direct+(sum(r.regression$coef*pop[,1])-sum(weights*(r.regression$coef*A[,1])))/N
}
fw(A,weights,0.5,0.5)
install.packages("rootSolve")
library(rootSolve)
?multiroot
q
d=weights
d
r.regression$coef
tempmatrix(c(rep(1,N),pop[,1]),N,2)
temp=matrix(c(rep(1,N),pop[,1]),N,2)
head(temp)
mean(temp%*%t( r.regression$coef))
t( r.regression$coef)
mean(temp%*%t(t( r.regression$coef)))
q.N.bar=0.1560506
n=length(q)
f=function(lambda)
{
c(sum(d/(lambda[1]+lambda[2]*q))+1,sum((d/(lambda[1]+lambda[2]*q)*q))+q.N.bar)
}
multiroot(f,start=c(1,1))
f=function(lambda)
{
c(sum(d/(lambda[1]+lambda[2]*q))+1,sum((d/(lambda[1]+lambda[2]*q)*q))+q.N.bar)
}
multiroot(f,start=c(1,1))
multiroot(f,start=c(1,1),maxiter=100)$root
lambda=multiroot(f,start=c(1,1),maxiter=100)$root
c(sum(d/(lambda[1]+lambda[2]*q))+1,sum((d/(lambda[1]+lambda[2]*q)*q))+q.N.bar)
max.weight=function(q,d,q.N.bar)
{
n=length(q)
f=function(lambda)
{
c(sum(d/(lambda[1]+lambda[2]*q))+1,sum((d/(lambda[1]+lambda[2]*q)*q))+q.N.bar)
}
lambda=multiroot(f,start=c(1,1),maxiter=100)$root\
-d/(lambda[1]+q*lambda[2])
}
max.weight=function(q,d,q.N.bar)
{
n=length(q)
f=function(lambda)
{
c(sum(d/(lambda[1]+lambda[2]*q))+1,sum((d/(lambda[1]+lambda[2]*q)*q))+q.N.bar)
}
lambda=multiroot(f,start=c(1,1),maxiter=100)$root
-d/(lambda[1]+q*lambda[2])
}
N=dim(pop)[1]
#' SRS samples
A=pop[sample(1:N,n,replace=FALSE),]
#' quantile regression
weights=rep(N/n,n)
PI=rep(n/N,n)
r.regression=rq(Y~X,tau=tau0,data=A,weights=weights)
q.N.bar=
q.direct=weighted.quantile(A[,2],tau,weights)
theta.w=q.direct+(sum(r.regression$coef*pop[,1])-sum(weights*(r.regression$coef*A[,1])))/N
q=r.regression$coef*A[,1]
Den=matrix(0,2,2)
Num=matrix(0,2,1)
for(i in  1:n)
{
Den=Den+weights[i]*matrix(c(1,q[i],q[i],q[i]^2),2,2)
Num=Num+weights[i]*matrix(c(1,q[i]),2,1)*(A[i,2]<theta.w)
}
C=solve(Den)%*%Num
z=(A[,2]<theta.w)-matrix(c(rep(1,n),q),n,2)%*%C
PIJ=matrix(n*(n-1)/N/(N-1),n,n)
diag(PIJ)=1/weights
V.hat=var(z)
V.hat
temp=matrix(c(rep(1,N),pop[,1]),N,2)
q.N.bar=mean(temp%*%t(t( r.regression$coef)))
q.N.bar
h=2*sqrt(V.hat)
max.weight(q,weights,q.bar)
max.weight(q,weights,q.N.bar)
sum(d/(lambda[1]+lambda[2]*q))+1
sum((d/(lambda[1]+lambda[2]*q)*q))+q.N.bar
f=function(lambda)
{
c(sum(d/(lambda[1]+lambda[2]*q))+1,sum((d/(lambda[1]+lambda[2]*q)*q))+q.N.bar)
}
lambda=multiroot(f,start=c(-1,-1),maxiter=100)$root
multiroot(f,start=c(-1,-1),maxiter=100)$root
multiroot(f,start=c(-1,-1),maxiter=100)
max.weight=function(q,d,q.N.bar)
{
n=length(q)
f=function(lambda)
{
c(sum(d/(lambda[1]+lambda[2]*q))+1,sum((d/(lambda[1]+lambda[2]*q)*q))+q.N.bar)
}
lambda=multiroot(f,start=c(-1,-1),maxiter=100)$root
-d/(lambda[1]+q*lambda[2])
}
max.weight(q,weights,q.N.bar)
sum(max.weight(q,weights,q.N.bar))
mean(max.weight(q,weights,q.N.bar)*q)
q.N.bar
q.N.bar
sum(max.weight(q,weights,q.N.bar)*q)
max.weight=function(q,d,q.N.bar)
{
n=length(q)
f=function(lambda)
{
c(sum(d/(lambda[1]+lambda[2]*q))+1,sum((d/(lambda[1]+lambda[2]*q)*q))+q.N.bar)
}
lambda=multiroot(f,start=c(-1,-1),maxiter=100)$root
w=-d/(lambda[1]+q*lambda[2])
w[w<0]=0
w
}
max.weight(q,weights,q.N.bar)
sum(max.weight(q,weights,q.N.bar))
sum(max.weight(q,weights,q.N.bar)*q)
q.N.bar
max.weight=function(q,d,q.N.bar)
{
n=length(q)
f=function(lambda)
{
c(sum(d/(lambda[1]+lambda[2]*q))+1,sum((d/(lambda[1]+lambda[2]*q)*q))+q.N.bar)
}
lambda=multiroot(f,start=c(-1,-1),maxiter=100)$root
#   w=-d/(lambda[1]+q*lambda[2])
#   w[w<0]=0
#   w
}
max.weight(q,weights,q.N.bar)
max.weight=function(q,d,q.N.bar)
{
n=length(q)
f=function(lambda)
{
c(sum(d/(lambda[1]+lambda[2]*q))+1,sum((d/(lambda[1]+lambda[2]*q)*q))+q.N.bar)
}
lambda=multiroot(f,start=c(-1,-1),maxiter=100)$root
-d/(lambda[1]+q*lambda[2])
#   w=-d/(lambda[1]+q*lambda[2])
#   w[w<0]=0
#   w
}
max.weight(q,weights,q.N.bar)
max.weight(q,weights,q.N.bar)[-d/(lambda[1]+q*lambda[2])<0]
fw
Fw=function(y,theta,weight)
{
data=cbind(y=y,weight=weight)
data=data.frame(data)
sum(weight[y<=theta])/sum(weight)
}
theta.2-h
theta.w-h
w=max.weight(q,weights,q.N.bar)
Fw(A[,2],theta.w-h,w)
theta.w-h
A[,2]
w
Fw(A[,2],theta.w-h,w)
Fw
Fw=function(y,theta,weight)
{
sum(weight[y<=theta])/sum(weight)
}
Fw(A[,2],theta.w-h,w)
y=A[,2]
theta=theta.w-h
weight=w
weight[y<=theta]
weight
y<=theta
y
y<=theta
y[1]<=theta
as.numeric(y)<=theta
as.numeric(y)<=as.numeic(theta)
as.numeric(y)<=as.numeric(theta)
y<=as.numeric(theta)
Fw=function(y,theta,weight)
{
sum(weight[y<=as.numeric(theta)])/sum(weight)
}
(Fw(A[,2],theta.w+h,w)-Fw(A[,2],theta.w-h,w))/(2*h)
var.kernel=function(pop,n,tau,tau0)
{
N=dim(pop)[1]
#' SRS samples
A=pop[sample(1:N,n,replace=FALSE),]
#' quantile regression
weights=rep(N/n,n)
PI=rep(n/N,n)
r.regression=rq(Y~X,tau=tau0,data=A,weights=weights)
q.N.bar=
q.direct=weighted.quantile(A[,2],tau,weights)
theta.w=q.direct+(sum(r.regression$coef*pop[,1])-sum(weights*(r.regression$coef*A[,1])))/N
q=r.regression$coef*A[,1]
Den=matrix(0,2,2)
Num=matrix(0,2,1)
for(i in  1:n)
{
Den=Den+weights[i]*matrix(c(1,q[i],q[i],q[i]^2),2,2)
Num=Num+weights[i]*matrix(c(1,q[i]),2,1)*(A[i,2]<theta.w)
}
C=solve(Den)%*%Num
z=(A[,2]<theta.w)-matrix(c(rep(1,n),q),n,2)%*%C
PIJ=matrix(n*(n-1)/N/(N-1),n,n)
diag(PIJ)=1/weights
V.hat=var(z)
#   for(i in 1:n)
#     for(j in 1:n)
#       V.hat=V.hat+(PIJ[i,j]-PI[i]*PI[j])*z[i]*z[j]/(PIJ[i,j]*PI[i]*PI[j])
#' to estimate the density of y
#   density=bkde(A[,2],kernel="normal")
#   index=min(which(density$x>theta.w))
#   f.theta=(density$y[index]+density$y[index-1])/2
temp=matrix(c(rep(1,N),pop[,1]),N,2)
q.N.bar=mean(temp%*%t(t( r.regression$coef)))
h=2*sqrt(V.hat)
w=max.weight(q,weights,q.N.bar)
f.theta=(Fw(A[,2],theta.w+h,w)-Fw(A[,2],theta.w-h,w))/(2*h)
V.theta=V.hat/f.theta^2
return(list(theta.w=theta.w,V.hat=V.hat,V.theta=V.theta))
}
var.kernel(pop1,100,0.5,0.5)
#' To calculate the bias of the variance estimate
#' We repeat the procedure 5000 times
#' We get th 5000 theta estimations and variance estimations
#' we use the mean of variance estimations as expected variance
#' we use 50000 theta to calculate v(theta)
r=sapply(1:5000,function(o) var.kernel(pop1,100,0.5,0.5))
E.V.hat=mean(unlist(r[3,]))
V.true=var(unlist(r[1,]))
(E.V.hat-V.true-1)*100
E.V.hat
V.true
quantile(rnorm(10000),probs=0.5)
unlist(r[1,])[1:10]
var(unlist(r[1,]))
mean(unlist(r[2,]))
tau-2*sqrt(V.hat)
sqrt(V.hat)
V.hat
tau+2*sqrt(V.hat)
