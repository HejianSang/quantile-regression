N=1000
pho1=0.6
pho2=0.9
mu=c(0,0)
sigma1=matrix(c(1,pho1,pho1,1),2,2)
sigma2=matrix(c(1,pho2,pho2,1),2,2)
library(quantreg)
library(mvtnorm)
install.packages("quantreg")
??rmv
pop1=rmvnorm(N,mean=mu,sigma=sigma1)
pop2=rmvnorm(N,mean=mu,sigma=sigma2)
library(quantreg)
library(mvtnorm)
# The simulation studies were conducted to compare the performance of calibrated
# quantile estimator to those of direct estimator and difference estimator.
# Two finite populations of size N = 1000 were generated from bivariate
# normal distribution respectively. The correlation between two variables in
# the first population is 0.9 and in the second population is 0.6.
N=1000
pho1=0.6
pho2=0.9
mu=c(0,0)
sigma1=matrix(c(1,pho1,pho1,1),2,2)
sigma2=matrix(c(1,pho2,pho2,1),2,2)
pop1=rmvnorm(N,mean=mu,sigma=sigma1)
pop2=rmvnorm(N,mean=mu,sigma=sigma2)
n=100
head(pop1)
pop1=data.frame(rmvnorm(N,mean=mu,sigma=sigma1))
names(pop1)=c("X","Y")
pop2=data.frame(rmvnorm(N,mean=mu,sigma=sigma2))
names(pop2)=c("X","Y")
head(pop1)
?rg
library(quantreg)
?rg
?rq
pop=pop1
N=dim(pop)[1]
A=pop[sample(1:N,n,replace=FALSE),]
weights=rep(N/n,n)
r.regression=rq(Y~X,tau=tau,data=A,weights=weights)
tau=0.3
r.regression=rq(Y~X,tau=tau,data=A,weights=weights)
r.regression
summary(r.regression)
rq.fit(A)
rq.fit(A[,1],A[,2])
r.regression
data(stackloss)
rq(stack.loss ~ stack.x,.5)
r.regression=rq(Y~X-1,tau=tau,data=A,weights=weights)
r.regression
r.regression$coef
sigma1
o.6/sqrt(1-0.6^2)
0.6/sqrt(1-0.6^2)
r.regression=rq(Y~X,tau=tau,data=A,weights=weights)
r.regression$coef
r.regression=rq(Y~X-1,tau=tau,data=A,weights=weights)
r.regression$coef
r.regression=rq(Y~X-1,tau=tau,data=A,weights=weights)
r.regression$coef
A[,1]*r.regression$coef
?qmorm
?qnorm
corr(pop)
?correlation
??corr
cor(pop)
cor(pop)[1,2]
?qnorm
N=dim(pop)[1]
rho=cor(pop)[1,2]
D=sapply(1:1000,function(o) {
A=pop[sample(1:N,n,replace=FALSE),]
weights=rep(N/n,n)
r.regression=rq(Y~X-1,tau=tau,data=A,weights=weights)
y.hat=r.regression$coef*A[,1]
y=sapply(A[,1],function(x) qnorm(tau,mean=rho*x,sd=sqrt(1-rho^2)))
sum((y-y.hat)^2)
})
mean(D)
Direct=fucntion(pop,n,tau)
{
N=dim(pop)[1]
rho=cor(pop)[1,2]
D=sapply(1:1000,function(o) {
A=pop[sample(1:N,n,replace=FALSE),]
weights=rep(N/n,n)
r.regression=rq(Y~X-1,tau=tau,data=A,weights=weights)
y.hat=r.regression$coef*A[,1]
y=sapply(A[,1],function(x) qnorm(tau,mean=rho*x,sd=sqrt(1-rho^2)))
sum((y-y.hat)^2)/n
})
mean(D)
}
Direct=function(pop,n,tau)
{
N=dim(pop)[1]
rho=cor(pop)[1,2]
D=sapply(1:1000,function(o) {
A=pop[sample(1:N,n,replace=FALSE),]
weights=rep(N/n,n)
r.regression=rq(Y~X-1,tau=tau,data=A,weights=weights)
y.hat=r.regression$coef*A[,1]
y=sapply(A[,1],function(x) qnorm(tau,mean=rho*x,sd=sqrt(1-rho^2)))
sum((y-y.hat)^2)/n
})
mean(D)
}
tau=c(0.1,0.3,0.5,0.7,0.9)
mse.d1=sapply(tau,function(tau) Diect(pop1,n,tau))
mse.d1=sapply(tau,function(tau) Direct(pop1,n,tau))
mse.d1
mse.d2=sapply(tau,function(tau) Direct(pop2,n,tau))
N=dim(pop)[1]
rho=cor(pop)[1,2]
D=sapply(1:1000,function(o) {
A=pop[sample(1:N,n,replace=FALSE),]
weights=rep(N/n,n)
r.regression=rq(Y~X-1,tau=tau,data=A,weights=weights)
y.hat=r.regression$coef*A[,1]
y=sapply(A[,1],function(x) qnorm(tau,mean=rho*x,sd=sqrt(1-rho^2)))
mse1=sum((y-y.hat)^2)/n
y.hat2=y.hat+(mean(r.regression$coef*pop[,1])-mean(y.hat))
mse2=sum((y-y.hat2)^2)/n
return(c(mse1,mse2))
})
(mean(r.regression$coef*pop[,1])-mean(y.hat))
N=dim(pop)[1]
rho=cor(pop)[1,2]
A=pop[sample(1:N,n,replace=FALSE),]
weights=rep(N/n,n)
r.regression=rq(Y~X-1,tau=tau,data=A,weights=weights)
y.hat=r.regression$coef*A[,1]
y=sapply(A[,1],function(x) qnorm(tau,mean=rho*x,sd=sqrt(1-rho^2)))
A[,1]
r.regression$coef
tau=0.5
N=dim(pop)[1]
rho=cor(pop)[1,2]
D=sapply(1:1000,function(o) {
A=pop[sample(1:N,n,replace=FALSE),]
weights=rep(N/n,n)
r.regression=rq(Y~X-1,tau=tau,data=A,weights=weights)
y.hat=r.regression$coef*A[,1]
y=sapply(A[,1],function(x) qnorm(tau,mean=rho*x,sd=sqrt(1-rho^2)))
mse1=sum((y-y.hat)^2)/n
y.hat2=y.hat+(mean(r.regression$coef*pop[,1])-mean(y.hat))
mse2=sum((y-y.hat2)^2)/n
return(c(mse1,mse2))
})
dim(D)
D[,1:10]
compare=function(pop,n,tau)
{
N=dim(pop)[1]
rho=cor(pop)[1,2]
D=sapply(1:1000,function(o) {
A=pop[sample(1:N,n,replace=FALSE),]
weights=rep(N/n,n)
r.regression=rq(Y~X-1,tau=tau,data=A,weights=weights)
y.hat=r.regression$coef*A[,1]
y=sapply(A[,1],function(x) qnorm(tau,mean=rho*x,sd=sqrt(1-rho^2)))
mse1=sum((y-y.hat)^2)/n
y.hat2=y.hat+(mean(r.regression$coef*pop[,1])-mean(y.hat))
mse2=sum((y-y.hat2)^2)/n
return(c(mse1,mse2))
})
apply(D,1,mean)
}
tau=c(0.1,0.3,0.5,0.7,0.9)
sapply(tau,function(tau) compare(pop1,n,tau))
A=pop[sample(1:N,n,replace=FALSE),]
weights=rep(N/n,n)
r.regression=rq(Y~X-1,tau=tau,data=A,weights=weights)
y.hat=r.regression$coef*A[,1]
y=sapply(A[,1],function(x) qnorm(tau,mean=rho*x,sd=sqrt(1-rho^2)))
mse1=sum((y-y.hat)^2)/n
tau=0.5
A=pop[sample(1:N,n,replace=FALSE),]
weights=rep(N/n,n)
r.regression=rq(Y~X-1,tau=tau,data=A,weights=weights)
y.hat=r.regression$coef*A[,1]
y=sapply(A[,1],function(x) qnorm(tau,mean=rho*x,sd=sqrt(1-rho^2)))
y
y.hat
y-y.hat
y.hat2=y.hat+(mean(r.regression$coef*pop[,1])-mean(y.hat))
y.hat2-y
(mean(r.regression$coef*pop[,1])-mean(y.hat))
N=1000
pho1=0.6
pho2=0.9
mu=c(0,0)
sigma1=matrix(c(1,pho1,pho1,1),2,2)
sigma2=matrix(c(1,pho2,pho2,1),2,2)
pop1=data.frame(rmvnorm(N,mean=mu,sigma=sigma1))
names(pop1)=c("X","Y")
pop2=data.frame(rmvnorm(N,mean=mu,sigma=sigma2))
names(pop2)=c("X","Y")
#'To use simple random sampling to get n=100 sample
n=100
N=dim(pop)[1]
rho=cor(pop)[1,2]
A=pop[sample(1:N,n,replace=FALSE),]
y=pop[A,2]
head(pop)
A
y=A[,2]
y
tau=0.3
weight=rep(1,100)
length(y)
total.weight=sum(weight)
f.hat=cumsum(weight)/total.weight
f.hat
which(f.hat>=tau)
weighted.quantile=function(y,tau,weight)
{
total.weight=sum(weight)
f.hat=cumsum(weight)/total.weight
indice=which(f.hat>=tau)
return(y[min(indice)])
}
weighted.quantile(y,0.5,weight)
weighted.quantile(y,0.6,weight)
weighted.quantile(y,0.7,weight)
y
x=c(3,1,2)
x
sort(x)
rank(x)
x[rank(x)]
sort(x)[rank(x)]
library(plyr)
?arrange
x[oder(x)]
x[order(x)]
data=cbind(y=y,weight=weight)
head(data)
data=data[order(data[,1]),]
head(data)
total.weight=sum(weight)
f.hat=cumsum(data$weight)/total.weight
data=data.frame(data)
total.weight=sum(weight)
f.hat=cumsum(data$weight)/total.weight
f.hat
indice=which(f.hat>=tau)
indice
return(y[min(indice)])
return(data$y[min(indice)])
data$y[min(indice)]
weighted.quantile=function(y,tau,weight)
{
data=cbind(y=y,weight=weight)
data=data[order(data[,1]),]
data=data.frame(data)
total.weight=sum(weight)
f.hat=cumsum(data$weight)/total.weight
indice=which(f.hat>=tau)
return(data$y[min(indice)])
}
weighted.quantile(y,0.3,weight)
weighted.quantile(y,0.4,weight)
weighted.quantile(y,0.5,weight)
weighted.quantile(y,0.33,weight)
weighted.quantile(y,0.31,weight)
weighted.quantile(y,0.29,weight)
f.hat
weighted.quantile(y,0.292,weight)
weighted.quantile(y,0.299,weight)
?quantile
r.regression
head(pop)
pop.regression=rq(Y~X-1,tau=tau,data=pop)
pop.regression
compare=function(pop,n,tau)
{
N=dim(pop)[1]
rho=cor(pop)[1,2]
pop.regression=rq(Y~X-1,tau=tau,data=pop)
beta.star=pop.regression$coef
pop.q.mean=mean(pop[,1]*beta.star)
D=sapply(1:1000,function(o) {
A=pop[sample(1:N,n,replace=FALSE),]
weights=rep(N/n,n)
r.regression=rq(Y~X-1,tau=tau,data=A,weights=weights)
q.direct=weighted.quantile(A[,2],tau,weights)
q.true=quantile(pop[,2],probs=tau)
mse1=(q.direct-q.true)^2
q.diff=q.direct+(mean(r.regression$coef*pop[,1])-mean(r.regression$coef*A[,1]))
mse2=(q.diff-q.true)^2
B=sum(r.regression$coef*A[,1]*(pop[,1]*beta.star-pop.q.mean))/sum((pop[,1]*beta.star-pop.q.mean)^2)
q.emp=q.direct+(pop.q.mean-mean(beta.star*A[,1]))*B
mse3=(q.emp-q.true)^2
return(c(mse1,mse2,mse3))
})
apply(D,1,mean)
}
tau=c(0.1,0.3,0.5,0.7,0.9)
sapply(tau,function(tau) compare(pop1,n,tau))
mse=sapply(tau,function(tau) compare(pop1,n,tau))
mse[1,]/mse[3,]
mse[2,]/mse[3,]
beta.star
compare=function(pop,n,tau)
{
N=dim(pop)[1]
rho=cor(pop)[1,2]
pop.regression=rq(Y~X-1,tau=tau,data=pop)
beta.star=pop.regression$coef
pop.q.mean=mean(pop[,1]*beta.star)
D=sapply(1:1000,function(o) {
A=pop[sample(1:N,n,replace=FALSE),]
weights=rep(N/n,n)
r.regression=rq(Y~X-1,tau=tau,data=A,weights=weights)
q.direct=weighted.quantile(A[,2],tau,weights)
q.true=quantile(pop[,2],probs=tau)
mse1=(q.direct-q.true)^2
q.diff=q.direct+(mean(r.regression$coef*pop[,1])-mean(r.regression$coef*A[,1]))
mse2=(q.diff-q.true)^2
B=sum(beta.star*pop[,1]*(pop[,1]*r.regression$coef-mean(r.regression$coef*pop[,1])))/
sum((pop[,1]*r.regression$coef-mean(r.regression$coef*pop[,1])^2))
q.emp=q.direct+(pop.q.mean-mean(beta.star*A[,1]))*B
mse3=(q.emp-q.true)^2
return(c(mse1,mse2,mse3))
})
apply(D,1,mean)
}
tau=c(0.1,0.3,0.5,0.7,0.9)
mse=sapply(tau,function(tau) compare(pop1,n,tau))
mse[1,]/mse[3,]
mse[2,]/mse[3,]
mse
weighted.quantile=function(y,tau,weight)
{
data=cbind(y=y,weight=weight)
data=data[order(data[,1]),]
data=data.frame(data)
total.weight=sum(weight)
f.hat=cumsum(data$weight)/total.weight
indice=which(f.hat>=tau)
return(data$y[min(indice)])
}
#' Direct Method and
#' We wan to use difference estimator
#' Difference estimator also use the auxilary information\
#' So we want to compare with callibartion method
compare=function(pop,n,tau)
{
N=dim(pop)[1]
rho=cor(pop)[1,2]
pop.regression=rq(Y~X-1,tau=tau,data=pop)
beta.star=pop.regression$coef
pop.q.mean=mean(pop[,1]*beta.star)
D=sapply(1:1000,function(o) {
A=pop[sample(1:N,n,replace=FALSE),]
weights=rep(N/n,n)
r.regression=rq(Y~X-1,tau=tau,data=A,weights=weights)
q.direct=weighted.quantile(A[,2],tau,weights)
q.true=quantile(pop[,2],probs=tau)
mse1=(q.direct-q.true)^2
q.diff=q.direct+(mean(r.regression$coef*pop[,1])-mean(r.regression$coef*A[,1]))
mse2=(q.diff-q.true)^2
B=sum(r.regression$coef*pop[,1]*(pop[,1]*beta.star-pop.q.mean))/sum((pop[,1]*beta.star-pop.q.mean)^2)
q.emp=q.direct+(pop.q.mean-mean(beta.star*A[,1]))*B
mse3=(q.emp-q.true)^2
return(c(mse1,mse2,mse3))
})
apply(D,1,mean)
}
tau=c(0.1,0.3,0.5,0.7,0.9)
mse=sapply(tau,function(tau) compare(pop1,n,tau))
mse[1,]/mse[3,]
mse[2,]/mse[3,]
mse=
mse
compare=function(pop,n,tau,tau0)
{
N=dim(pop)[1]
rho=cor(pop)[1,2]
pop.regression=rq(Y~X-1,tau=tau0,data=pop)
beta.star=pop.regression$coef
pop.q.mean=mean(pop[,1]*beta.star)
D=sapply(1:1000,function(o) {
A=pop[sample(1:N,n,replace=FALSE),]
weights=rep(N/n,n)
r.regression=rq(Y~X-1,tau=tau0,data=A,weights=weights)
q.direct=weighted.quantile(A[,2],tau,weights)
q.true=quantile(pop[,2],probs=tau)
mse1=(q.direct-q.true)^2
q.diff=q.direct+(pop.q.mean-mean(beta.star*A[,1]))
mse2=(q.diff-q.true)^2
B=sum(r.regression$coef*pop[,1]*(pop[,1]*beta.star-pop.q.mean))/sum((pop[,1]*beta.star-pop.q.mean)^2)
q.emp=q.direct+(pop.q.mean-mean(beta.star*A[,1]))*B
mse3=(q.emp-q.true)^2
return(c(mse1,mse2,mse3))
})
apply(D,1,mean)
}
tau=c(0.1,0.3,0.5,0.7,0.9)
mse=sapply(tau,function(tau) compare(pop1,n,tau,0.3))
mse[1,]/mse[3,]
mse[2,]/mse[3,]
